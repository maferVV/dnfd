<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create this object so it is around all the time. Properties.

/*
Usage: 

Create this object so it is around all the time. 
To make something pathfind it just needs to be a child of obj_pathfindable.
you can then call find_path() to queue it up 
event_user(10) gets run when the path has been found

*/
//gml_release_mode(1)

instance_create(0,0,obj_pathfinding_manager) // make the manager that will queue tasts for this object. 


//#macro CHECKSPERFRAME 40 // bigger numbers will finish pathfinding in less frames but take up more CPU during those frames 
// PF_CPU_TIME = game_get_speed(gamespeed_microseconds)*0.5 // microseconds
// lower numbers are faster
enum ground {
   wateropen = 1,
   roadfast = 1,
   roadslow = 4,
   grass = 25,
   mud = 50,
   impassable = PF_LARGESTNUMBER
}

route = path_add() // where we save it 
path_set_closed(route, false)
path_set_kind(route,1)
path_set_precision(route,2)
pf_queue_x = ds_priority_create()
pf_queue_y = ds_priority_create()
cell_width = 16
cell_height = 16
// ????
h_cells = floor(room_height/cell_height); //40
v_cells = floor(room_width/cell_width); //40
start_x = 0;
start_y = 0;
end_x = h_cells;//30
end_y = v_cells;//30
terrain = ds_grid_create(h_cells,v_cells);
fastest = ds_grid_create(h_cells,v_cells);
checked = ds_grid_create(h_cells,v_cells);
processing = false;
finished_spreadout = false;
object_id = -1; // would you like an object to have a callback?
// for timing the pathfindin 
pf_timer_start = 0
pf_timer_end = 0 // used for debugging only 
pf_debug_loop_count = 0 // debugging the number of times it looped before it was told to stop 
pf_debug_frames_to_calculate_last_path = 0

/****** BUILD GRID "terrain" HERE *********/


// for drawing 

debug = false&amp;&amp;global.debug;
draw_map = true;
draw_map_text = false;
draw_paths = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cleanup


path_delete(route)

ds_grid_destroy(terrain)
ds_grid_destroy(fastest)
ds_grid_destroy(checked)

ds_priority_destroy(pf_queue_x)
ds_priority_destroy(pf_queue_y)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Process pathfinding



if (processing == true) {
	find_path_mainloop()
}
if (finished_spreadout = true) {
	finished_spreadout = false	
	find_path_end() // turn the spreadout into a path
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw cells and info

if(debug)
{
    if(draw_map)
    {
        draw_set(1, c_green, fnt_mono_mini);
        draw_rectangle(0,0,h_cells*cell_width,v_cells*cell_height,false);
        for (var h = 0; h &lt; h_cells; ++h)
        {
            for (var v = 0; v &lt; v_cells; ++v)
            {
                switch(terrain[# h,v])
                {
                    case ground.roadfast:
                        draw_set_colour(c_ltgray)
                        draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
                        break;
                    case ground.roadslow:
                        draw_set_colour(c_gray)
                        draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
                        break;
                    case ground.mud:
                        draw_set_colour(c_maroon)
                        draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
                        break;
                    case ground.impassable:
                        draw_set_colour(c_black)
                        draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
                        break;
                }
                // for debugging:
                if(draw_map_text)
                {
                    var todisplay = fastest[# h,v]
                    if (todisplay != PF_LARGESTNUMBER)
                    { 
                        draw_set_colour(c_black)
                        draw_text(h*cell_width,v*cell_height,round(todisplay))
                    }
                    else
                    {
                        draw_set_colour(c_red)
                    }
                }
            }
        }
    }
    
    if(draw_paths)
    {
        // draw the last path you made
        draw_set(1, c_white);
        draw_path(route,cell_width/2,cell_height/2,true);
        
        // draw the whole database of paths 
        draw_set(0.8, c_white);
        var size = ds_map_size(obj_pathfinding_manager.pathfinding_database);
        var key = ds_map_find_first(obj_pathfinding_manager.pathfinding_database);
        for (var i = 0; i &lt; size; i++;)
        {
            draw_path(obj_pathfinding_manager.pathfinding_database[? key],0,0,true);
            key=ds_map_find_next(obj_pathfinding_manager.pathfinding_database, key);
        }
    }
    
    draw_set();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
